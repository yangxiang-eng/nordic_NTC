
#include <stdio.h>
#include <stdint.h>
#include <float.h>
#include "nrf_log.h"
#include "stroge_data.h"


#if  defined(SAD1115_DIF_mod) || defined(AS1115_single_mod)
#define  DETLA_TEMPERATURE 50
#else 
#define  DETLA_TEMPERATURE 40
#endif

typedef  struct storget{
  uint32_t adc_to_temp_data ; 
}storget_data ; 

//TDK 根据曲线公式,差分电阻
#ifdef BOARD_KN5_DIFF_MOD
static storget_data gap_target_data[]={
{190030	},
{180003	 },
{170558	 },
{161658	 },
{153269	 },
{145361	 },
{137905	 },
{130871	 },
{124234	 },
{117971	 },
{112057	 },
{106473	 },
{101197	 },
{96211	 },
{91498	 },
{87042	 },
{82826	 },
{78838	 },
{75063	 },
{71489	 },
{68104	 },
{64898	 },
{61860	 },
{58980	 },
{56250	 },
{53662	 },
{51206	 },
{48876	 },
{46665	 },
{44566	 },
{42573	 },
{40680	 },
{38882	 },
{37172	 },
{35547	 },
{34002	 },
{32531	 },
{31132	 },
{29800	 },
{28532	 },
{27325	 },
{26175	 },
{25080	 },
{24037	 },
{23044	 },
{22100	 },
{21203	 },
{20352	 },
{19547	 },
{18786	 },
{17973	 },
{17258	 },
{16575	 },
{15922	 },
{15299	 },
{14703	 },
{14133	 },
{13589	 },
{13068	 },
{12570	 },
{12093	 },
{11637	 },
{11201	 },
{10783	 },
{10383	 },
{10000	 },
{9633	 },
{9281	 },
{8944	 },
{8621	 },
{8311	 },
{8014	 },
{7729	 },
{7456	 },
{7194	 },
{6942	 },
{6701	 },
{6469	 },
{6246	 },
{6032	 },
{5826	 },
{5629	 },
{5439	 },
{5257	 },
{5082	 },
{4913	 },
{4751	 },
{4596	 },
{4446	 },
{4302	 },
{4164	 },
{4030	 },
{3902	 },
{3779	 },
{3660	 },
{3546	 },
{3436	 },
{3330	 },
{3228	 },
{3130	 },
{3020	 },
{2927	 },
{2838	 },
{2752	 },
{2669	 },
{2589	 },
{2511	 },
{2437	 },
{2365	 },
{2295	 },
{2228	 },
{2163	 },
{2100	 },
{2039	 },
{1981	 },
{1924	 },
{1870	 },
{1817	 },
{1765	 },
{1716	 },
{1668	 },
{1622	 },
{1577	 },
{1533	 },
{1491	 },
{1451	 },
};
#endif


//TDK等分电阻
#ifdef  TDK
static storget_data gap_target_data[]={
{9500	 },
{9477	 },
{9451	 },
{9423	 },
{9391	 },
{9356	 },
{9328	 },
{9296	 },
{9261	 },
{9223	 },
{9181	 },
{9146	 },
{9108	 },
{9066	 },
{9020	 },
{8970	 },
{8928	 },
{8882	 },
{8833	 },
{8779	 },
{8720	 },
{8670	 },
{8617	 },
{8560	 },
{8497	 },
{8429	 },
{8373	 },
{8312	 },
{8246	 },
{8175	 },
{8098	 },
{8034	 },
{7965	 },
{7892	 },
{7813	 },
{7727	 },
{7656	 },
{7581	 },
{7500	 },
{7413	 },
{7321	 },
{7244	 },
{7162	 },
{7075	 },
{6983	 },
{6884	 },
{6802	 },
{6716	 },
{6624	 },
{6527	},
{6425	},
{6340	},
{6250	},
{6155	},
{6056	},
{5952	},
{5865	},
{5773	},
{5678	},
{5578	},
{5474	},
{5386	},
{5295	},
{5201	},
{5103	},
{5000	 },
{4914	 },
{4825	 },
{4733	 },
{4638	 },
{4539	 },
{4456	 },
{4370	 },
{4282	 },
{4191	 },
{4097	 },
{4019	 },
{3938	 },
{3854	 },
{3769	 },
{3681	 },
{3607	 },
{3532	 },
{3454	 },
{3375	 },
{3294	 },
{3225	 },
{3155	 },
{3084	 },
{3011	 },
{2937	 },
{2875	 },
{2811	 },
{2746	 },
{2680	 },
{2613	 },
{2556	 },
{2498	 },
{2439	 },
{2380	 },
{2319	 },
{2301	 },
{2249	 },
{2197	 },
{2145	 },
{2056	 },
{2011	 },
{1964	 },
{1917	 },
{1870	 },
{1822	 },
{1781	 },
{1740	 },
{1698	 },
{1656	 },
{1614	 },
{1578	 },
{1541	 },
{1504	 },
{1467	 },
{1430	 },

}; 
#endif

//TDK根据曲线公式,获取电阻
#if defined(BOARD_D62) || defined(KN5_V3)

static storget_data gap_target_data[]={
{500		    },
{526		    },
{554		    },
{583		    },
{612		    },
{644		    },
{676		    },
{710		    },
{745		    },
{781		    },
{819		    },
{859		    },
{899		    },
{942		    },
{985		    },
{1030	  },
{1077	  },
{1126	  },
{1176	  },
{1227	  },
{1280	  },
{1335	  },
{1392	  },
{1450	  },
{1509	  },
{1571	  },
{1634	  },
{1698	  },
{1765	  },
{1833	  },
{1902	  },
{1973	  },
{2046	  },
{2120	  },
{2196	  },
{2273	  },
{2351	  },
{2431	  },
{2513	  },
{2595	  },
{2679	  },
{2764	  },
{2851	  },
{2938	  },
{3026	  },
{3115	  },
{3205	  },
{3295	  },
{3384	  },
{3474	  },
{3575	  },
{3669	  },
{3763	  },
{3858	  },
{3953	  },
{4048	  },
{4144	  },
{4239	  },
{4335	  },
{4431	  },
{4526	  },
{4622	  },
{4717	  },
{4812	  },
{4906	  },
{5000	  },
{5094	  },
{5186	  },
{5279	  },
{5370	  },
{5461	  },
{5551	  },
{5640	  },
{5729	  },
{5816	  },
{5902	  },
{5988	  },
{6072	  },
{6155	  },
{6238	  },
{6319	  },
{6398	  },
{6477	  },
{6554	  },
{6631	  },
{6705	  },
{6779	  },
{6851	  },
{6922	  },
{6992	  },
{7060	  },
{7127	  },
{7193	  },
{7257	  },
{7321	  },
{7382	  },
{7443	  },
{7502	  },
{7559	  },
{7616	  },
{7681	  },
{7736	  },
{7789	  },
{7842	  },
{7893	  },
{7944	  },
{7993	  },
{8041	  },
{8088	  },
{8133	  },
{8178	  },
{8222	  },
{8264	  },
{8306	  },
{8347	  },
{8386	  },
{8425	  },
{8463	  },
{8499	  },
{8535	  },
{8570	  },
{8605	  },
{8638	  },
{8670	  },
{8702	  },
{8733	  },

};

#endif

#if defined (BOARD_KN5_DIFF_MOD) || defined(BOARD_D62) || defined(KN5_V3)
static float adc_value_to_temp_situation(uint32_t big_measure_value , uint32_t small_measure_value ,uint16_t samle_value_temp,float target);
float search_data(float target)
{
  //target *100 ; 
   uint32_t target_val = (uint32_t)target; 

  //int 
   int left = 0 ;
   int right = sizeof(gap_target_data) / sizeof(gap_target_data[0]) -1 ;
   while(left < right)
   {
      int mid = (left + right) /2 ;
       uint32_t res = gap_target_data[mid].adc_to_temp_data;
      if(target_val == res)
      {
        return mid - DETLA_TEMPERATURE ; 
        
      }
      //当前值大于目标值并且下一个值小于目标值
      else if(gap_target_data[mid].adc_to_temp_data > target_val && gap_target_data[mid+1].adc_to_temp_data < target_val)
      {
        //printf("two temp,temp1 :%d,temp2:%d\n",gap_target_data[mid].temp_data ,gap_target_data[mid+1].temp_data );

        return adc_value_to_temp_situation(gap_target_data[mid].adc_to_temp_data,gap_target_data[mid+1].adc_to_temp_data,mid,target_val);
      }
      //当前值小于目标值并且上一个值大于目标值
      else if(gap_target_data[mid].adc_to_temp_data < target_val && gap_target_data[mid-1].adc_to_temp_data > target_val)
      {
        //printf("two temp_value , value1:%d,value2:%d\n",gap_target_data[mid-1].temp_data,gap_target_data[mid].temp_data);
        
        return adc_value_to_temp_situation(gap_target_data[mid-1].adc_to_temp_data,gap_target_data[mid].adc_to_temp_data,mid-1,target_val);
      }
      else if(gap_target_data[mid].adc_to_temp_data > target_val)
      {
        left = mid +1 ; 
      }
      else 
      {
        right = mid  ; 
      }
   }
}

//number1 > number2 and number1 > target , number2 < target , val == number1.temp

//onec situation
static float adc_value_to_temp_situation(uint32_t big_measure_value , uint32_t small_measure_value ,uint16_t samle_value_temp,float target)
{
  float ans =(1.0-((float)(target - small_measure_value))/(float)((big_measure_value - small_measure_value)))+ samle_value_temp - DETLA_TEMPERATURE ;
  //NRF_LOG_INFO("measure temp value :%d\n",(int)(ans * 100)); 
  return ans ; 
}

#endif
//1115 单端模式
#ifdef  ASD1115_single_mod
static storget_data gap_target_data[]={
{9847.11	 },
{9836.21	 },
{9824.63	 },
{9812.34	 },
{9799.29	 },
{9785.46	 },
{9770.81	 },
{9755.28	 },
{9738.85	 },
{9721.47	 },
{9703.10	 },
{9683.70	 },
{9663.21	 },
{9641.60	 },
{9618.81	 },
{9594.80	 },
{9569.52	 },
{9542.92	 },
{9514.96	 },
{9485.57	 },
{9454.72	 },
{9422.35	 },
{9388.41	 },
{9352.86	 },
{9315.64	 },
{9276.70	 },
{9236.01	 },
{9193.50	 },
{9149.14	 },
{9102.88	 },
{9054.69	 },
{9004.52	 },
{8952.34	 },
{8898.11	 },
{8841.80	 },
{8783.38	 },
{8722.84	 },
{8660.15	 },
{8595.29	 },
{8528.24	 },
{8459.03	 },
{8387.62	 },
{8314.00	 },
{8238.23	 },
{8160.31	 },
{8080.21	 },
{7998.04	 },
{7913.75	 },
{7827.41	 },
{7739.04	 },
{7648.76	 },
{7556.56	 },
{7462.52	 },
{7366.70	 },
{7269.18	 },
{7170.03	 },
{7069.35	 },
{6967.21	 },
{6863.71	 },
{6758.94	 },
{6653.02	 },
{6546.03	 },
{6438.09	 },
{6329.32	 },
{6219.81	
{6109.69	 },
{5999.06	 },
{5888.06	 },
{5776.78	 },
{5665.37	 },
{5553.90	 },
{5442.53	 },
{5331.34	 },
{5220.43	 },
{5109.95	 },
{5000.00	 },
{4890.66	 },
{4782.02	 },
{4674.19	 },
{4567.28	 },
{4461.34	 },
{4356.47	 },
{4252.77	 },
{4150.27	 },
{4049.07	  },
{3949.19	  },
{3850.73	  },
{3753.75	  },
{3658.28	  },
{3564.33	  },
{3471.99	  },
{3381.30	  },
{3292.24	  },
{3204.86	  },
{3119.16	  },
{3035.19	  },
{2952.98	  },
{2872.47	  },
{2793.68	  },
{2716.68	  },
{2641.38	  },
{2567.82	  },
{2496.04	  },
{2425.91	  },
{2357.54	  },
{2290.85	  },
{2225.82	  },
{2162.46	  },
{2100.67	  },
{2040.56	  },
{1982.04	  },
{1925.06	  },
{1869.59	  },
{1815.69	  },
{1763.24	  },
{1712.25	  },
{1662.71	  },
{1614.54	  },
{1567.73	  },
{1522.26	  },
{1478.12	  },
{1435.28	  },
{1393.63	  },
{1353.22	  },
{1314.02	  },
{1275.90	  },
{1238.98	  },
{1203.15	  },
{1168.34	  },
{1134.59	  },
{1101.86	  },
{1070.15	  },
{1039.35	  },
{1009.54	  },
{980.59	  },
{952.52	  },
{925.26	  },
{898.83	  },
{873.25	  },
{848.44	  },
{824.43	  },
{801.05	  },
{778.48	  },
{756.57	  },
{735.25	  },
{714.69	  },
{694.73	  },
{675.30	  },
{656.56	  },
{638.28	  },
{620.63	  },
{603.53	  },
{586.91	  },
{570.84	  },
{555.26	  },
{540.07	  },
{525.37	  },
{511.16	  },
{497.37	  },
{483.98	  },
{470.93	  },
{458.38	  },
{446.16	  },
{434.28	  },
{422.74	  },
{411.63	  },
{400.77	  },
{390.25	  },
{379.99	  },
{370.08	  },
{360.52	  },
{351.22	  },
{342.08	  },
{333.31	  },
{324.80	  },
{316.46	  },
{308.48	  },
{300.58	  },
{293.05	  },
{285.70	  },
{278.52	  },
{271.52	  },
{264.80	  },
{258.16	  },
{251.80	  },
{245.62	  },
{239.62	  },
{233.74	  },
{228.05	  },
{222.52	  },
{217.13	  },
{211.90	  },
{206.81	  },
{201.87	  },
{197.07	  },
{192.39	  },
{187.83	  },
{183.41	  },
{179.11	  },
{174.93	  },
{170.85	  },
{166.89	  },
{163.03	  },
{159.27	  },
{155.62	  },
{152.06	  },
{148.60	  },
{145.22	  },
{141.94	  },
{138.75	  },
{135.64	  },
{132.60	  },
{129.65	  },
{126.77	  },
{123.97	  },
{121.24	  },
{118.59	  },
{115.99	  },
{113.47	  },
{111.00	  },
{108.61	  },
{106.27	  },
{103.99	  },
{101.76	  },
{99.60	  },
{97.49	  },
{95.43	  },
{93.42	  },
{91.47	  },
{89.55	  },
{87.68	  },
{85.87	  },
{84.10	  },
{82.37	  },
{80.67	  },
{79.03	  },
{77.42	  },
{75.85	  },
{74.31	  },
{72.83	  },
{71.36	  },
{69.94	  },
{68.55	  },
{67.19	  },
{65.85	  },
{64.56	  },
{63.30	  },
{62.06	  },
{60.85	  },
{59.67	  },
{58.52	  },
{57.39	  },
{56.29	  },
{55.21	  },
{54.16	  },
{53.14	  },
{52.13	  },
{51.15	  },
{50.19	  },
{49.25	  },
{48.33	  },
{47.43	  },
{46.55	  },
{45.69	  },
{44.86	  },
{44.04	  },
{43.23	  },
{42.45	  },
{41.68	  },
{40.92	  },
{40.19	  },
{39.47	  },
{38.77	  },
{38.07	  },
{37.40	  },
{36.73	  },
{36.09	  },
{35.46	  },
{34.84	  },
{34.23	  },
{33.64	  },
{33.06	  },
{32.48	  },
{31.93	  },
{31.38	  },
{30.84	  },
{30.33	  },
{29.81	  },
{29.30	  },
{28.82	  },
{28.33	  },
{27.86	  },
{27.39	  },
{26.94	  },
{26.50	  },
{26.06	  },
{25.63	  },
{25.22	  },
{24.80	  },
{24.40	  },
{24.00	  },
{23.61	  },
{23.24	  },
{22.87	  },
{22.50	  },
{22.14	  },
{21.79	  },
{21.44	  },
{21.11	  },
{20.78	  },
{20.45	  },
{20.13	  },
{19.82	  },
{19.51	  },
{19.21	  },
{18.91	  },
{18.63	  },
{18.34	  },
{18.06	  },
{17.79	  },
{17.52	  },
{17.25	  },
{16.99	  },
{16.74	  },
{16.48	  },
{16.24	  },
{16.00	  },
{15.77	  },
{15.54	  },
{15.31	  },
{15.08	  },
{14.86	  },
{14.64	  },
{14.43	  },
{14.22	  },
{14.02	  },
{13.81	  },
{13.62	  },
{13.42	  },
{13.23	  },
{13.04	  },
{12.86	  },
{12.68	  },
{12.50	  },
{12.32	  },
{12.16	  },
{11.99	  },
{11.82	  },
{11.66	  },
{11.50	  },
{11.34	  },
};

static float adc_value_to_temp_situation(uint32_t big_measure_value , uint32_t small_measure_value ,uint16_t samle_value_temp,float target);
float search_data(float target)
{
  //target *100 ; 
   uint32_t target_val = (uint32_t)target; 

  //int 
   int left = 0 ;
   int right = sizeof(gap_target_data) / sizeof(gap_target_data[0]) -1 ;
   while(left < right)
   {
      int mid = (left + right) /2 ;
       uint32_t res = gap_target_data[mid].adc_to_temp_data;
      if(target_val == res)
      {
        return mid - DETLA_TEMPERATURE ; 
        
      }
      //当前值大于目标值并且下一个值小于目标值
      else if(gap_target_data[mid].adc_to_temp_data > target_val && gap_target_data[mid+1].adc_to_temp_data < target_val)
      {
        //printf("two temp,temp1 :%d,temp2:%d\n",gap_target_data[mid].temp_data ,gap_target_data[mid+1].temp_data );

        return adc_value_to_temp_situation(gap_target_data[mid].adc_to_temp_data,gap_target_data[mid+1].adc_to_temp_data,mid,target_val);
      }
      //当前值小于目标值并且上一个值大于目标值
      else if(gap_target_data[mid].adc_to_temp_data < target_val && gap_target_data[mid-1].adc_to_temp_data > target_val)
      {
        //printf("two temp_value , value1:%d,value2:%d\n",gap_target_data[mid-1].temp_data,gap_target_data[mid].temp_data);
        
        return adc_value_to_temp_situation(gap_target_data[mid-1].adc_to_temp_data,gap_target_data[mid].adc_to_temp_data,mid-1,target_val);
      }
      else if(gap_target_data[mid].adc_to_temp_data > target_val)
      {
        left = mid +1 ; 
      }
      else 
      {
        right = mid  ; 
      }
   }
}

//number1 > number2 and number1 > target , number2 < target , val == number1.temp

//onec situation
static float adc_value_to_temp_situation(uint32_t big_measure_value , uint32_t small_measure_value ,uint16_t samle_value_temp,float target)
{
  float ans =(1.0-((float)(target - small_measure_value))/(float)((big_measure_value - small_measure_value)))+ samle_value_temp - DETLA_TEMPERATURE ;
  //NRF_LOG_INFO("measure temp value :%d\n",(int)(ans * 100)); 
  return ans ; 
}



#endif

//1115差分模式
#if defined (K6PB_DIF_mod) || defined(SAD1115_DIF_mod)  
static storget_data gap_target_data[]={
{155	},
{167	},
{179	},
{191	},
{205	},
{219	},
{235	},
{251	},
{268	},
{287	},
{306	},
{327	},
{349	},
{372	},
{396	},
{422	},
{450	},
{479	},
{510	},
{542	},
{577	},
{613	},
{651	},
{692	},
{735	},
{780	},
{827	},
{877	},
{930	},
{986	},
{1044	},
{1106	},
{1170	},
{1238	},
{1310	},
{1385	},
{1464	},
{1547	},
{1634	},
{1726	},
{1822	},
{1922	},
{2028	},
{2139	},
{2254	},
{2376	},
{2503	},
{2636	},
{2776	},
{2921	},
{3074	},
{3234	},
{3400	},
{3575	},
{3757	},
{3947	},
{4146	},
{4353	},
{4569	},
{4795	},
{5031	},
{5276	},
{5533	},
{5799	},
{6078	},
{6367	},
{6669	},
{6984	},
{7311	},
{7651	},
{8005	},
{8374	},
{8757	},
{9155	},
{9570	},
{10000	},
{10447	},
{10912	},
{11394	},
{11895	},
{12415	},
{12954	},
{13514	},
{14095	},
{14697	},
{15322	},
{15969	},
{16640	},
{17335	},
{18056	},
{18802	},
{19574	},
{20374	},
{21203	},
{22060	},
{22947	},
{23864	},
{24813	},
{25795	},
{26810	},
{27859 },
{28944 },
{30063 },
{31222 },
{32417 },
{33652 },
{34927 },
{36244 },
{37604 },
{39006 },
{40453 },
{41946 },
{43488 },
{45076 },
{46714 },
{48403 },
{50143 },
{51937 },
{53787 },
{55692 },
{57654 },
{59673 },
{61755 },
{63898 },
{66103 },
{68376 },
{70711 },
{73115 },
{75592 },
{78137 },
{80756 },
{83445 },
{86214 },
{89055 },
{91979 },
{94985 },
{98078 },
{101256},
{104515},
{107863},
{111297},
{114837},
{118455},
{122175},
{126008},
{129921},
{133941},
{138083},
{142308},
{146671},
{151126},
{155690},
{160385},
{165180},
{170097},
{175162},
{180343},
{185632},
{191058},
{196618},
{202347},
{208160},
{214133},
{220264},
{226552},
{232937},
{239521},
{246245},
{253165},
{260213},
{267380},
{274725},
{282326},
{290023},
{297885},
{305998},
{314169},
{322685},
{331236},
{340020},
{349040},
{358295},
{367647},
{377358},
{387147},
{397141},
{407332},
{417833},
{428504},
{439406},
{450552},
{461915},
{473530},
{485366},
{497438},
{509788},
{522384},
{535217},
{548306},
{561672},
{575308},
{589206},
{603391},
{617856},
{632591},
{647626},
{662954},
{678610},
{694541},
{710732},
{727273},
{744158},
{761325},
{778816},
{796622},
{814797},
{833264},
{852152},
{871308},
{890869},
{910747},
{931012},
{951656},
{972668},
{994036},
{1015744},
{1037883},
{1060445},
{1083306},
{1106684},
{1130454},
{1154601},
{1179106},
{1204094},
{1229559},
{1255335},
{1281723},
{1308387},
{1335648},
{1363141},
{1391401},
{1419849},
{1448855},
{1478415},
{1508523},
{1538935},
{1569859},
{1601281},
{1633453},
{1665834},
{1698947},
{1732502},
{1766472},
{1801153},
{1836547},
{1871958},
{1908397},
{1945147},
{1982554},
{2020610},
{2059308},
{2098196},
{2138123},
{2178649},
{2219263},
{2260909},
{2303086},
{2345766},
{2389486},
{2433682},
{2478315},
{2523341},
{2569373},
{2616431},
{2663825},
{2712232},
{2760906},
{2809778},
{2860412},
{2911208},
{2962963},
{3014772},
{3068426},
{3122073},
{3176620},
{3232062},
{3287311},
{3344482},
{3402518},
{3460208},
{3519887},
{3579098},
{3640335},
{3702332},
{3763643},
{3827019},
{3891051},
{3955696},
{4022526},
{4088307},
{4156276},
{4224757},
{4293688},
{4363002},
{4434590},
{4506534},
{4578755},
{4653327},
{4728132},
{4803074},
{4880429},
{4957858},
{5035247},
{5115090},
{5194805},
{5277045},
{5359057},
{5443658},
{5527916},
{5611672},
{5698006},
{5787037},
{5875441},
{5963029},
{6056935},
{6146281},
{6238303},
{6333122},
{6426735},
{6523157},
{6622517},
{6720430},
{6821282},
{6920415},
{7022472},
{7122507},
{7230658},
{7331378},
{7440476},
{7547170},
{7656968},
{7763975},
{7874016},
{7987220},
{8103728},
{8216927},
{8333333},
{8453085},
{8568980},
{8688097},
{8810573},
};
#endif 





#if defined (K6PB_DIF_mod) || defined(SAD1115_DIF_mod)

static float adc_value_to_temp_situation(uint32_t big_measure_value , uint32_t small_measure_value ,uint16_t samle_value_temp,float target);
float search_data(float target)
{
    //target *100 ; 
    uint32_t target_val = (uint32_t)target;

    //int 
    int left = 0;
    int right = sizeof(gap_target_data) / sizeof(gap_target_data[0]) - 1;
    while (left < right)
    {
            
        int mid = (left + right) / 2;
        uint32_t res =  gap_target_data[mid].adc_to_temp_data;
        //如果当前值等于目标值返回
        if (target_val == res)
        {
            return mid - DETLA_TEMPERATURE;
            //printf("get once succue\n");

        }
        //当前值小于目标值并且下一个值大于目标值
        else if (gap_target_data[mid].adc_to_temp_data < target_val && gap_target_data[mid + 1].adc_to_temp_data > target_val)
        {
            //printf("two temp,temp1 :%d,temp2:%d\n",gap_target_data[mid].temp_data ,gap_target_data[mid+1].temp_data );

            return adc_value_to_temp_situation(gap_target_data[mid + 1].adc_to_temp_data, gap_target_data[mid].adc_to_temp_data, mid, target_val);
        }
        //当前值大于目标值并且上一个值小于目标值
        else if (gap_target_data[mid].adc_to_temp_data > target_val && gap_target_data[mid - 1].adc_to_temp_data < target_val)
        {
            //printf("two temp_value , value1:%d,value2:%d\n",gap_target_data[mid-1].temp_data,gap_target_data[mid].temp_data);

            return adc_value_to_temp_situation(gap_target_data[mid].adc_to_temp_data, gap_target_data[mid - 1].adc_to_temp_data, mid-1, target_val);
        }
        else if (gap_target_data[mid].adc_to_temp_data > target_val)
        {
            right = mid;
        }
        else
        {
            left = mid + 1;
        }
    }
}

//number1 > number2 and number1 > target , number2 < target , val == number1.temp

//onec situation
static float adc_value_to_temp_situation(uint32_t big_measure_value, uint32_t small_measure_value, uint16_t samle_value_temp, float target)
{
    float ans = (samle_value_temp - DETLA_TEMPERATURE) + (((float)(target - small_measure_value)) / (float)((big_measure_value - small_measure_value)))  ;
   //printf("measure temp value :%f\n",ans ); 
    return ans;
}


#endif





